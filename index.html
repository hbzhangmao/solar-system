<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>å¤ªé˜³-åœ°çƒ-æœˆçƒ è¿åŠ¨æ¨¡æ‹Ÿ</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #0a0a2e; font-family: 'Helvetica Neue', 'PingFang SC', sans-serif; }
canvas { display: block; }

#info {
  position: absolute; top: 10px; left: 10px; color: #fff;
  font-size: 14px; background: rgba(0,0,0,0.6); padding: 12px 16px;
  border-radius: 10px; pointer-events: none; line-height: 1.6;
  backdrop-filter: blur(8px);
}

#controls {
  position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
  display: flex; gap: 10px; align-items: center; flex-wrap: wrap; justify-content: center;
  background: rgba(0,0,0,0.55); padding: 12px 20px; border-radius: 12px;
  color: #fff; font-size: 13px; backdrop-filter: blur(8px);
}
#speedRange { width: 100px; cursor: pointer; accent-color: #ffaa00; }

.btn {
  padding: 7px 14px; border: none; border-radius: 8px; cursor: pointer;
  font-size: 13px; font-weight: 600; color: #fff; transition: all 0.2s;
  background: rgba(255,255,255,0.12); backdrop-filter: blur(4px);
  border: 1px solid rgba(255,255,255,0.15);
}
.btn:hover { background: rgba(255,255,255,0.25); transform: scale(1.05); }
.btn.active { background: rgba(255,170,0,0.5); border-color: rgba(255,170,0,0.7); }
.btn-pause { font-size: 16px; min-width: 42px; }
.btn-pause.paused { background: rgba(76,175,80,0.5); border-color: rgba(76,175,80,0.7); }

#event-info {
  position: absolute; top: 10px; right: 10px; color: #fff;
  font-size: 13px; background: rgba(0,0,0,0.7); padding: 14px 18px;
  border-radius: 10px; max-width: 320px; line-height: 1.7;
  backdrop-filter: blur(8px); display: none;
  border: 1px solid rgba(255,170,0,0.3);
}
#event-info h3 { margin-bottom: 6px; color: #ffcc44; font-size: 15px; }

#transition-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: #000; opacity: 0; pointer-events: none; z-index: 100;
  transition: opacity 0.6s ease;
}
#transition-overlay.active { opacity: 1; }
</style>
</head>
<body>
<div id="transition-overlay"></div>
<div id="info">
  ğŸŒ å¤ªé˜³ &nbsp; ğŸŒ åœ°çƒ &nbsp; ğŸŒ™ æœˆçƒ<br>
  é¼ æ ‡æ‹–æ‹½æ—‹è½¬ Â· æ»šè½®ç¼©æ”¾ Â· å³é”®å¹³ç§»
</div>
<div id="event-info"></div>
<div id="controls">
  <button class="btn btn-pause" id="pauseBtn" title="æš‚åœ/ç»§ç»­">â¸</button>
  <label>é€Ÿåº¦: <input type="range" id="speedRange" min="0" max="5" step="0.1" value="1"></label>
  <span id="speedVal">1.0x</span>
  <div style="width:1px;height:20px;background:rgba(255,255,255,0.2);margin:0 4px"></div>
  <button class="btn" id="btnSolarEclipse">ğŸŒ‘ æ—¥é£Ÿ</button>
  <button class="btn" id="btnLunarEclipse">ğŸŒ• æœˆé£Ÿ</button>
  <button class="btn" id="btnNormal">ğŸ”„ æ­£å¸¸è§†è§’</button>
</div>

<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// --- Scene ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 2000);
camera.position.set(0, 80, 160);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.minDistance = 5;
controls.maxDistance = 500;

// --- State ---
let paused = false;
let speed = 1;
let currentMode = 'normal'; // 'normal' | 'solar-eclipse' | 'lunar-eclipse'
let cameraTarget = null; // smooth camera transition target
let cameraLookTarget = null;
let transitionProgress = 0;
let transitionDuration = 2.0;
let transitioning = false;
let savedCameraPos = null;
let savedControlsTarget = null;

// --- Starfield ---
const starGeo = new THREE.BufferGeometry();
const starCount = 8000;
const starPos = new Float32Array(starCount * 3);
const starColors = new Float32Array(starCount * 3);
for (let i = 0; i < starCount; i++) {
  starPos[i*3] = (Math.random() - 0.5) * 1800;
  starPos[i*3+1] = (Math.random() - 0.5) * 1800;
  starPos[i*3+2] = (Math.random() - 0.5) * 1800;
  const c = 0.7 + Math.random() * 0.3;
  const tint = Math.random();
  starColors[i*3] = tint > 0.8 ? c : c * 0.9;
  starColors[i*3+1] = c * 0.95;
  starColors[i*3+2] = tint < 0.2 ? c : c * 0.85;
}
starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
starGeo.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ size: 0.6, vertexColors: true })));

// --- Texture helper ---
function makeCanvasTexture(size, drawFn) {
  const c = document.createElement('canvas');
  c.width = c.height = size;
  drawFn(c.getContext('2d'), size);
  return new THREE.CanvasTexture(c);
}

// --- Sun ---
const sunTex = makeCanvasTexture(512, (ctx, s) => {
  const g = ctx.createRadialGradient(s/2, s/2, 0, s/2, s/2, s/2);
  g.addColorStop(0, '#fff8e0');
  g.addColorStop(0.3, '#ffcc00');
  g.addColorStop(0.7, '#ff8800');
  g.addColorStop(1, '#cc4400');
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, s, s);
  for (let i = 0; i < 200; i++) {
    ctx.fillStyle = `rgba(255,${100+Math.random()*100|0},0,${Math.random()*0.3})`;
    const x = Math.random()*s, y = Math.random()*s, r = Math.random()*8+2;
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
  }
});
const sun = new THREE.Mesh(new THREE.SphereGeometry(12, 64, 64), new THREE.MeshBasicMaterial({ map: sunTex }));
scene.add(sun);

// Sun corona (outer glow)
const coronaMat = new THREE.SpriteMaterial({
  map: makeCanvasTexture(512, (ctx, s) => {
    const g = ctx.createRadialGradient(s/2, s/2, s*0.1, s/2, s/2, s/2);
    g.addColorStop(0, 'rgba(255,220,100,0.5)');
    g.addColorStop(0.3, 'rgba(255,160,50,0.15)');
    g.addColorStop(0.6, 'rgba(255,100,20,0.05)');
    g.addColorStop(1, 'rgba(255,80,0,0)');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, s, s);
  }),
  transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
});
const corona = new THREE.Sprite(coronaMat);
corona.scale.set(55, 55, 1);
sun.add(corona);

// Sun light with shadows
const sunLight = new THREE.PointLight(0xfff0dd, 2, 500);
sunLight.castShadow = true;
sunLight.shadow.mapSize.width = 2048;
sunLight.shadow.mapSize.height = 2048;
scene.add(sunLight);
scene.add(new THREE.AmbientLight(0x668899, 1.2));

// --- Earth ---
const earthTex = makeCanvasTexture(512, (ctx, s) => {
  ctx.fillStyle = '#2980b9';
  ctx.fillRect(0, 0, s, s);
  ctx.fillStyle = '#2ecc71';
  const continents = [
    [120,80,90,70],[280,60,80,50],[350,120,60,80],
    [100,200,120,60],[250,180,70,90],[380,250,80,60],
    [200,300,100,70],[60,320,50,40],[320,350,60,50]
  ];
  continents.forEach(([x,y,w,h]) => {
    ctx.beginPath();
    ctx.ellipse(x*s/512, y*s/512, w*s/1024, h*s/1024, Math.random(), 0, Math.PI*2);
    ctx.fill();
  });
  ctx.fillStyle = '#ecf0f1';
  ctx.fillRect(0, 0, s, s*0.06);
  ctx.fillRect(0, s*0.94, s, s*0.06);
  for (let i = 0; i < 80; i++) {
    ctx.fillStyle = `rgba(255,255,255,${Math.random()*0.15})`;
    ctx.beginPath();
    ctx.ellipse(Math.random()*s, Math.random()*s, Math.random()*40+10, Math.random()*15+5, Math.random()*Math.PI, 0, Math.PI*2);
    ctx.fill();
  }
});
const earthMat = new THREE.MeshPhongMaterial({ map: earthTex, shininess: 25, emissive: 0x112244, emissiveIntensity: 0.15 });
const earth = new THREE.Mesh(new THREE.SphereGeometry(5, 48, 48), earthMat);
earth.castShadow = true;
earth.receiveShadow = true;

const earthPivot = new THREE.Object3D();
scene.add(earthPivot);
earth.position.x = 60;
earthPivot.add(earth);
earth.rotation.z = 23.4 * Math.PI / 180;

// Earth atmosphere
const atmosMat = new THREE.MeshPhongMaterial({
  color: 0x4488ff, transparent: true, opacity: 0.12,
  side: THREE.BackSide, blending: THREE.AdditiveBlending
});
const atmos = new THREE.Mesh(new THREE.SphereGeometry(5.8, 48, 48), atmosMat);
earth.add(atmos);

// --- Moon ---
const moonTex = makeCanvasTexture(256, (ctx, s) => {
  ctx.fillStyle = '#e8e8e8';
  ctx.fillRect(0, 0, s, s);
  for (let i = 0; i < 60; i++) {
    const x = Math.random()*s, y = Math.random()*s, r = Math.random()*12+3;
    ctx.fillStyle = `rgba(${180+Math.random()*40|0},${180+Math.random()*40|0},${180+Math.random()*40|0},0.6)`;
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = `rgba(240,240,240,0.3)`;
    ctx.beginPath(); ctx.arc(x-r*0.2, y-r*0.2, r*0.7, 0, Math.PI*2); ctx.fill();
  }
});
const moon = new THREE.Mesh(
  new THREE.SphereGeometry(1.5, 32, 32),
  new THREE.MeshPhongMaterial({ map: moonTex, shininess: 5, emissive: 0x222222, emissiveIntensity: 0.2 })
);
moon.castShadow = true;
moon.receiveShadow = true;

const moonPivot = new THREE.Object3D();
earth.add(moonPivot);
moon.position.x = 12;
moonPivot.add(moon);
moonPivot.rotation.x = 5.14 * Math.PI / 180;

// --- Shadow cone visualization (for eclipses) ---
const shadowConeGeo = new THREE.ConeGeometry(3, 20, 32, 1, true);
const shadowConeMat = new THREE.MeshBasicMaterial({
  color: 0x000000, transparent: true, opacity: 0.08,
  side: THREE.DoubleSide, blending: THREE.NormalBlending, depthWrite: false
});
const earthShadowCone = new THREE.Mesh(shadowConeGeo, shadowConeMat.clone());
earthShadowCone.visible = false;
scene.add(earthShadowCone);

const moonShadowCone = new THREE.Mesh(
  new THREE.ConeGeometry(1.5, 15, 32, 1, true),
  shadowConeMat.clone()
);
moonShadowCone.visible = false;
scene.add(moonShadowCone);

// --- Orbit lines ---
function makeOrbitLine(radius, parent, color = 0x444466) {
  const pts = [];
  for (let i = 0; i <= 128; i++) {
    const a = (i / 128) * Math.PI * 2;
    pts.push(new THREE.Vector3(Math.cos(a) * radius, 0, Math.sin(a) * radius));
  }
  const line = new THREE.Line(
    new THREE.BufferGeometry().setFromPoints(pts),
    new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.35 })
  );
  parent.add(line);
  return line;
}
const earthOrbitLine = makeOrbitLine(60, scene, 0x3366aa);
const moonOrbitLine = makeOrbitLine(12, earth, 0x666688);

// --- Labels ---
function makeLabel(text, parent, yOffset) {
  const c = document.createElement('canvas');
  c.width = 256; c.height = 64;
  const ctx = c.getContext('2d');
  ctx.font = 'bold 36px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#fff';
  ctx.fillText(text, 128, 42);
  const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
    map: new THREE.CanvasTexture(c), transparent: true, depthTest: false
  }));
  sprite.scale.set(12, 3, 1);
  sprite.position.y = yOffset;
  parent.add(sprite);
  return sprite;
}
const sunLabel = makeLabel('å¤ªé˜³', sun, 16);
const earthLabel = makeLabel('åœ°çƒ', earth, 8);
const moonLabel = makeLabel('æœˆçƒ', moon, 3.5);

// --- Eclipse positioning ---
// For solar eclipse: moon between sun and earth (as seen from earth)
// For lunar eclipse: earth between sun and moon (earth shadow on moon)

function positionForSolarEclipse() {
  // Place moon directly between sun and earth
  // Reset pivots so earth is at known position
  earthPivot.rotation.y = 0; // earth at +X
  moonPivot.rotation.x = 0; // flatten moon orbit
  moonPivot.rotation.y = Math.PI; // moon on sun-side of earth (between sun and earth)
}

function positionForLunarEclipse() {
  // Place moon directly behind earth (earth between sun and moon)
  earthPivot.rotation.y = 0;
  moonPivot.rotation.x = 0;
  moonPivot.rotation.y = 0; // moon on far side of earth from sun
}

// --- Camera transitions ---
function smoothTransitionTo(targetPos, lookAt, duration = 2.0) {
  savedCameraPos = camera.position.clone();
  savedControlsTarget = controls.target.clone();
  cameraTarget = targetPos.clone();
  cameraLookTarget = lookAt.clone();
  transitionProgress = 0;
  transitionDuration = duration;
  transitioning = true;
}

function easeInOutCubic(t) {
  return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2;
}

// --- Event info panel ---
const eventInfoEl = document.getElementById('event-info');
function showEventInfo(title, lines) {
  eventInfoEl.innerHTML = `<h3>${title}</h3>` + lines.map(l => `<div>${l}</div>`).join('');
  eventInfoEl.style.display = 'block';
}
function hideEventInfo() {
  eventInfoEl.style.display = 'none';
}

// --- Eclipse modes ---
function enterSolarEclipse() {
  currentMode = 'solar-eclipse';
  paused = true;
  updatePauseBtn();

  positionForSolarEclipse();

  // Get earth world position
  const earthWorldPos = new THREE.Vector3();
  earth.getWorldPosition(earthWorldPos);
  const moonWorldPos = new THREE.Vector3();
  moon.getWorldPosition(moonWorldPos);

  // Camera: from earth looking toward sun, slightly offset to see moon blocking
  const camPos = new THREE.Vector3(
    earthWorldPos.x + 8,
    earthWorldPos.y + 3,
    earthWorldPos.z + 10
  );
  smoothTransitionTo(camPos, moonWorldPos, 2.0);

  // Show shadow cones
  earthShadowCone.visible = false;
  moonShadowCone.visible = true;

  showEventInfo('ğŸŒ‘ æ—¥é£Ÿ Solar Eclipse', [
    'æœˆçƒè¿è¡Œåˆ°å¤ªé˜³å’Œåœ°çƒä¹‹é—´',
    'æœˆçƒçš„å½±å­æŠ•å°„åˆ°åœ°çƒè¡¨é¢',
    'ä»åœ°çƒä¸Šçœ‹ï¼Œå¤ªé˜³è¢«æœˆçƒé®æŒ¡',
    '',
    'æ—¥å…¨é£Ÿæ—¶å¯ä»¥çœ‹åˆ°å¤ªé˜³çš„æ—¥å†•',
    'æ—¥é£Ÿæ¯å¹´å‘ç”Ÿ2-5æ¬¡',
    'åŒä¸€åœ°ç‚¹å¹³å‡375å¹´æ‰èƒ½çœ‹åˆ°ä¸€æ¬¡æ—¥å…¨é£Ÿ'
  ]);

  document.getElementById('btnSolarEclipse').classList.add('active');
  document.getElementById('btnLunarEclipse').classList.remove('active');
}

function enterLunarEclipse() {
  currentMode = 'lunar-eclipse';
  paused = true;
  updatePauseBtn();

  positionForLunarEclipse();

  const earthWorldPos = new THREE.Vector3();
  earth.getWorldPosition(earthWorldPos);
  const moonWorldPos = new THREE.Vector3();
  moon.getWorldPosition(moonWorldPos);

  // Camera: side view to see alignment
  const midPoint = new THREE.Vector3().lerpVectors(earthWorldPos, moonWorldPos, 0.5);
  const camPos = new THREE.Vector3(
    midPoint.x,
    midPoint.y + 15,
    midPoint.z + 20
  );
  smoothTransitionTo(camPos, midPoint, 2.0);

  earthShadowCone.visible = true;
  moonShadowCone.visible = false;

  showEventInfo('ğŸŒ• æœˆé£Ÿ Lunar Eclipse', [
    'åœ°çƒè¿è¡Œåˆ°å¤ªé˜³å’Œæœˆçƒä¹‹é—´',
    'åœ°çƒçš„å½±å­æŠ•å°„åˆ°æœˆçƒä¸Š',
    'æœˆçƒè¿›å…¥åœ°çƒæœ¬å½±æ—¶å˜ä¸ºæš—çº¢è‰²',
    '',
    'è¿™ç§çº¢è‰²è¢«ç§°ä¸º"è¡€æœˆ"',
    'æ˜¯å› ä¸ºåœ°çƒå¤§æ°”æŠ˜å°„çº¢å…‰åˆ°æœˆçƒ',
    'æœˆå…¨é£Ÿæ¯å¹´å‘ç”Ÿ0-3æ¬¡',
    'æŒç»­æ—¶é—´å¯è¾¾1å°æ—¶40åˆ†é’Ÿ'
  ]);

  document.getElementById('btnLunarEclipse').classList.add('active');
  document.getElementById('btnSolarEclipse').classList.remove('active');
}

function enterNormal() {
  currentMode = 'normal';
  earthShadowCone.visible = false;
  moonShadowCone.visible = false;
  moonPivot.rotation.x = 5.14 * Math.PI / 180;
  hideEventInfo();

  const targetPos = new THREE.Vector3(0, 80, 160);
  const lookAt = new THREE.Vector3(0, 0, 0);
  smoothTransitionTo(targetPos, lookAt, 1.5);

  document.getElementById('btnSolarEclipse').classList.remove('active');
  document.getElementById('btnLunarEclipse').classList.remove('active');

  if (paused) {
    paused = false;
    updatePauseBtn();
  }
}

// --- Pause ---
const pauseBtn = document.getElementById('pauseBtn');
function updatePauseBtn() {
  pauseBtn.textContent = paused ? 'â–¶' : 'â¸';
  pauseBtn.classList.toggle('paused', paused);
}
pauseBtn.addEventListener('click', () => {
  paused = !paused;
  updatePauseBtn();
});

// Keyboard shortcut: Space to pause
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' && e.target === document.body) {
    e.preventDefault();
    paused = !paused;
    updatePauseBtn();
  }
});

// --- Speed control ---
const speedRange = document.getElementById('speedRange');
const speedVal = document.getElementById('speedVal');
speedRange.addEventListener('input', () => {
  speed = parseFloat(speedRange.value);
  speedVal.textContent = speed.toFixed(1) + 'x';
});

// --- Button events ---
document.getElementById('btnSolarEclipse').addEventListener('click', enterSolarEclipse);
document.getElementById('btnLunarEclipse').addEventListener('click', enterLunarEclipse);
document.getElementById('btnNormal').addEventListener('click', enterNormal);

// --- Update shadow cones ---
function updateShadowCones() {
  if (moonShadowCone.visible) {
    const moonWorld = new THREE.Vector3();
    moon.getWorldPosition(moonWorld);
    const sunWorld = new THREE.Vector3();
    sun.getWorldPosition(sunWorld);

    // Cone from moon toward earth (away from sun)
    const dir = moonWorld.clone().sub(sunWorld).normalize();
    moonShadowCone.position.copy(moonWorld).add(dir.clone().multiplyScalar(7.5));
    moonShadowCone.lookAt(moonWorld.clone().add(dir.clone().multiplyScalar(100)));
    moonShadowCone.rotateX(Math.PI / 2);
  }

  if (earthShadowCone.visible) {
    const earthWorld = new THREE.Vector3();
    earth.getWorldPosition(earthWorld);
    const sunWorld = new THREE.Vector3();
    sun.getWorldPosition(sunWorld);

    const dir = earthWorld.clone().sub(sunWorld).normalize();
    earthShadowCone.position.copy(earthWorld).add(dir.clone().multiplyScalar(10));
    earthShadowCone.lookAt(earthWorld.clone().add(dir.clone().multiplyScalar(100)));
    earthShadowCone.rotateX(Math.PI / 2);
  }
}

// --- Lunar eclipse: tint moon red when in earth shadow ---
const moonOriginalEmissive = new THREE.Color(0x222222);
const moonEclipseEmissive = new THREE.Color(0x881111);

function updateMoonEclipseColor() {
  if (currentMode === 'lunar-eclipse') {
    moon.material.emissive.lerp(moonEclipseEmissive, 0.05);
    moon.material.emissiveIntensity = THREE.MathUtils.lerp(moon.material.emissiveIntensity, 0.6, 0.05);
  } else {
    moon.material.emissive.lerp(moonOriginalEmissive, 0.05);
    moon.material.emissiveIntensity = THREE.MathUtils.lerp(moon.material.emissiveIntensity, 0.2, 0.05);
  }
}

// --- Animation ---
const clock = new THREE.Clock();
function animate() {
  requestAnimationFrame(animate);
  const rawDt = clock.getDelta();

  // Camera transition
  if (transitioning) {
    transitionProgress += rawDt / transitionDuration;
    if (transitionProgress >= 1) {
      transitionProgress = 1;
      transitioning = false;
    }
    const t = easeInOutCubic(transitionProgress);
    camera.position.lerpVectors(savedCameraPos, cameraTarget, t);
    controls.target.lerpVectors(savedControlsTarget, cameraLookTarget, t);
  }

  if (!paused) {
    const dt = rawDt * speed;
    sun.rotation.y += dt * 0.1;
    earthPivot.rotation.y += dt * 0.3;
    earth.rotation.y += dt * 2;
    moonPivot.rotation.y += dt * 1.2;
    moon.rotation.y += dt * 1.2;
  }

  updateShadowCones();
  updateMoonEclipseColor();
  controls.update();
  renderer.render(scene, camera);
}
animate();

// --- Resize ---
addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
<a href="https://hbzhangmao.github.io/portal/" style="position:fixed;top:12px;right:12px;z-index:9999;background:rgba(99,102,241,0.9);color:#fff;text-decoration:none;padding:6px 14px;border-radius:20px;font-size:13px;font-family:-apple-system,sans-serif;backdrop-filter:blur(8px);box-shadow:0 2px 8px rgba(0,0,0,0.3);transition:opacity 0.2s;opacity:0.7;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'">ğŸ  å¯¼èˆª</a>
</body>
</html>
